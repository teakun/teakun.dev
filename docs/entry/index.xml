<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Entries on teakun.dev</title>
    <link>https://teakun.dev/entry/</link>
    <description>Recent content in Entries on teakun.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 11 Jun 2023 17:16:19 +0900</lastBuildDate><atom:link href="https://teakun.dev/entry/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swiftでの最高のenumパースを考える</title>
      <link>https://teakun.dev/entry/2023-06-11-swift-enum-parse-best-way/</link>
      <pubDate>Sun, 11 Jun 2023 17:16:19 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2023-06-11-swift-enum-parse-best-way/</guid>
      <description>APIから受け取ったJSONをパースし、enumに変換して利用するときの考慮ポイントを整理したい。
例えば次のようなECサイトで商品の状態を表すenumがあったとする。
enum ItemStatus: String, Decodable { case new case used case junk } 絶対にこのどれかが返却されるならこのままでもいいけど、現実はケアしたいケースがいっぱいある。
 新機能の追加で新しい種類が返却されるようになった 実は想定外の値が返却される仕様だった サーバサイドの不具合で全く関係のない文字列が入ってしまった  などなど。
状況に応じてenumのパースをどのように実装していくのがよいかを考えてみる。
考えられる実装パターン 取れる作戦を並べると以下のパターンになる。
 エラーに倒す 想定外を表現する専用のケースを用意する 既存にあるケースに倒す  エラーに倒す 想定外の値が帰ってきた場合にパース処理自体を失敗にする。 値を厳密に扱いたい場合にやりがち。
enum ItemStatus: String, Decodable { case new case used case junk public init(from decoder: Decoder) throws { let stringValue = try decoder.singleValueContainer().decode(String.self) if let status = ItemStatus(rawValue: stringValue) { self = status } else { throw ParseError() // 好きなエラーを返す } } } リクエスト全体を失敗にしてしまうのでenumパースだけに問題があった場合でも全体が影響を受けてしまうが、絶対に想定しているケースだけを扱いたい場合にはこれ。 全部エラーに倒してしまうので、サーバサイドに更新があって新しいケースが追加されたとき強制アップデートなどの旧アプリのケアが必須になってしまうのがデメリット。 お金周りや住所など、クリティカルな情報向き。</description>
    </item>
    
    <item>
      <title>SwiftPackageManager再入門</title>
      <link>https://teakun.dev/entry/2023-01-08-detail-of-swiftpm/</link>
      <pubDate>Sun, 08 Jan 2023 22:12:03 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2023-01-08-detail-of-swiftpm/</guid>
      <description>Swift Package Manager (以下SwiftPM)中心の構成が最近流行っているが、そのためにはSwiftPMの仕組みや用語を改めてしっかりと理解しておきたい。 公式のドキュメントを参考にしつつ自分が知っていることをまとめてみる。
SwiftPMとは 概要 SwiftPMとはなにか。公式サイトにはこのようにある。
 Swift Package Manager は、Swift コードの配布を管理するためのツールです。依存関係のダウンロード、コンパイル、およびリンクのプロセスを自動化するために、Swiftビルドシステムと統合されています。
 SwiftPM自体はツールの名前で、基本的には他の人が作ったライブラリの導入・管理に利用される。 SwiftPMはSwiftにデフォルトでついてくるので余計な外部ツールを入れる必要がないのが嬉しい。 これまではGitHubなどで配布されているライブラリを使うためにはcocoapodsやcarthageなど、外部のツールを利用するのが一般的だった。 出たばかりの頃は不安定だったがだいぶ安定してきてきており、最近はほぼデファクトスタンダートと言ってよい状態。
基本的な概念 Module importができる単位。SwiftPMによらずcocoapodsやcarthageでもModuleが作られる。 SwiftPMの公式のドキュメントを読んでいるとModuleという言葉が頻発するけどSwiftPMのクラスにModuleというのは存在しない。
Package SwiftPMにおける一番大きな単位。PackageはソースファイルとPackage.swiftと呼ばれるマニフェストファイルから構成される。 パッケージは1つ以上のTargetを持っている。
Target コードを1つにまとめた単位。この単位で名前空間ができて、どの部分を外部から使えるようにするかを決める。publicを付与したものが外部から参照できる。 Target同士は依存関係を持つことができる。SwiftPMにおいてはModuleに近い存在。 Module/Product/Targetの関係がややこしいなと思っているけどフォーラムに同じようなことを質問している人がいた。
Products Packageが提供するものを定義して、他のパッケージから見えるようにしたもの。定義できる種類は以下の3種類。
 Library: 大体がこれ、コードをライブラリとして提供する場合はこちら。 Plugin: ビルドツールなど。Swiftlintなどの。 Executable: これは使ったことない。実行ファイル？  Dependency モジュール(Target)間の依存関係のこと。依存関係はさらに依存関係を持つことができる。 この依存関係は循環してはいけない。
導入 SwiftPMで提供されている外部のライブラリを利用したいとき、導入方法は大きく分けて2つある。
 Xcodeのプロジェクト上から追加 ローカルで追加したSwiftPMのPackage経由で追加  一般的に紹介される方法は1で、ネットで検索すると基本的にはこれが紹介されている。 これはXcode上からポチポチするだけなので非常に簡単。 詳細なやり方はこのあたりが詳しい。
SwiftPM中心の構成にする場合は基本的に2を採用することになる。 1の方法だとライブラリを追加したときの変更がxcodeprojに反映されるので変更の差分が読みにくいが、2だとPackage.swiftに反映されるので変更が追いやすい。 1の方法はネットを探せばいっぱいでてくるのでこの記事では2の導入方法を紹介する。
プロジェクトへのSwiftPMの追加 プロジェクトにSwiftPMのPackageを追加するところまでを紹介。 まずは対象のプロジェクト上でNew→Packageを選択。  適当な名前をつけて、Add toとGroupにプロジェクト名を選択してCreateする。  これでプロジェクト上にSwiftPMのPackageが配置される。  次はプロジェクト側からSwiftPMのモジュールを参照する設定を追加する。 xcodeproj → targets → general → Framework, Libraries, and Embedded Contentで+を選択、作ったモジュールを選択して追加。  ここまででプロジェクトからローカルにおいたSwiftPMのPackageを扱う環境が最低限整った。 あとはPackageに対してモジュール・外部のライブラリを追加すればよしなにプロジェクト側から利用することができる。</description>
    </item>
    
    <item>
      <title>2022</title>
      <link>https://teakun.dev/entry/2022-12-29-2022/</link>
      <pubDate>Thu, 29 Dec 2022 14:55:58 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2022-12-29-2022/</guid>
      <description>2022年振り返り。3年目なのでそろそろ毎年恒例といってもいいでしょう。
生活 変わらず東京にいる。 コロナもさすがにどうでも良くなってきて、ちょいちょい旅行に行くこともできた。 今年行った旅行先としては新潟がベスト。たまたま寄ったワイナリーが良かった。 6月ごろにはついにコロナにかかったりもした。東京都から大量の非常食品が送られてきた思い出。 ここ数年は大きく生活が変わっていないが、ちょっとずつ良くなっている気はする。
仕事 4~9月にかけて半年間の期間限定で別の部署への異動があった。 新卒入社以来ずっと同じ部署の同じような環境で働いていて変化が欲しかったところ、会社の都合といい感じに噛み合って異動が叶った。 一度違う環境を味わってみたいと思っていたけどなかなかに過酷な環境だった。 よく言われるメテオフォール開発に当てはまると思う。半年だけで本当に良かった。 仕事の様子としてはプロジェクト全体をリードする人が多忙でうまく回っていない状況で、開発は勝手に仕様を解釈していくような流れ。 コミュニケーションが最小限なので開発側としては楽だけど手戻りが多い。 なんとかしたかったが人気が半年限定ということもありそのあたりは最低限のことしかできず。 サービスの仕様にもいろいろ口を出してみたりしてみたけれど、メテオフォールに抗うことも難しく折れてしまうこともあった。 大企業の中の大きい力が働く案件はいろいろ難しい。 今回は何ともできなかったがこれを反面教師にしたい。 技術としては自分が中心になって技術方針の選定を決める機会が多くあった。 一通りを自分が決めた上で、うまくそれがチームの開発にハマった感覚があって気持ちよかった。1人でアプリを1本立ち上げられる自信をつけた。
9月後半ごろからは元のチームに戻ったがもうチームに先輩はいなくなっていた。 ということで、10月からはチームのマネージャーになった。 自分のこれからのキャリアを考えてマネジメントは一度経験してみたかったので、ありがたい機会をいただいた。 1on1やら調整やら、大事そうなことから余計なことまでいろいろと仕事が新しくなった。 一方でマネージャーになってからはコードを書く機会がしっかり減ってしまったのでなんとかしたい。 マネジメントをやりつつコードをモリモリ書くのが当面の目標。 去年の終わりに、来年は本業に変化をつけたい、と書いてたのでそのあたりは多少達成できた。
副業はやっていたけど、なんやかんやでやめてしまった。 今年は成長中のベンチャーでflutterの開発。成長していると正社員の数も増えて、業務委託の出番がいずれなくなってしまう。 正社員が増えたところに自分の稼働時間が取れないことも重なって契約解除となった。 業務委託として仕事を受ける難しさを感じる。 本業が忙しいのもあって余裕が少ないので当分はこのままになりそう。 副業やら自分のアプリやらを頑張る余力を取り戻していきたい。
2023 文量を見る通り今年は仕事の振り返りで筆が乗ってしまった。 確かに分かりやすい変化は仕事に多かった。来年は仕事以外も気合い入れていく。ワークライフバランス。</description>
    </item>
    
    <item>
      <title>XcodeのカスタムテンプレートがSwiftPMの中で使えなかったので直す</title>
      <link>https://teakun.dev/entry/2022-05-11-xcode-template-in-swiftpm/</link>
      <pubDate>Wed, 11 May 2022 23:32:34 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2022-05-11-xcode-template-in-swiftpm/</guid>
      <description>Xcodeでの開発効率向上のために用意したカスタムテンプレートが、ローカルに置いたSwiftPMの中で使えない問題があったのでそれに対応したメモ。 自分の場合、ローカルにおいたSwiftPMはマルチモジュール構成のために用意したもの。
前提  環境  Xcode13.3.1   起きていた問題  ローカルに置いたSwiftPMのSourceに対してNew File → Choose a template your new fileで表示されるテンプレートの一覧に独自のテンプレートが表示されない アプリ本体に対してテンプレートを選択しようとする場合は、独自に用意したテンプレートは表示される (テンプレートの追加は概ねこの記事のとおりにやっている https://zenn.dev/paraches/articles/xcode-custom-template)    原因・対応 SwiftPMの中でテンプレートを利用したい場合は、TemplateInfo.plistに専用のパラメータを追加しておく必要があった。 SupportsSwiftPackageというパラメータがあるのでこれをtrueにしておくとSwiftPMからもカスタムテンプレートが利用できる。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;SupportsSwiftPackage&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; … &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; 独自に追加したテンプレートだけが表示されないのが不思議でデフォルトで用意されているコードテンプレートを覗いてみたところ、いかにも怪しいパラメータを見つけることができて解決した。 デフォルトのテンプレートは/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File\ Templates/にあるのでこれを参考にする。 Template.infoの書き方をちゃんと理解したかったけど、公式のドキュメントがないようでちょっと厳しい。。</description>
    </item>
    
    <item>
      <title>@IBOutletにはweakを付けるべきなのか</title>
      <link>https://teakun.dev/entry/2022-04-22-iboutlet-strong-good/</link>
      <pubDate>Fri, 22 Apr 2022 23:02:49 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2022-04-22-iboutlet-strong-good/</guid>
      <description>よくあるこういうコードで、weakを付けるべきか付けないべきか。
@IBOutlet weak var newButton: UIButton! swiftformatを導入するにあたってこのルールを入れるべきかという議論になったが、weakの有無によってどのような違いがあるのかわからなかったので調べてみる。
そもそも付ける付けないでどのような違いがあるかを調べる。(参考)
 weak付ける(弱参照, weak)  removeFromSuperviewしたタイミングでviewが開放される 弱参照なのでretaincountがなくなって開放される   weak付けない(強参照, strong)  removeFromSuperviewしてもviewが開放されない weakが付いていないのでviewへの参照が残っている    合わせて、swiftformatのルール説明に公式の動画へのリンクがあるのでそれをちゃんと見る。 公式は基本的にIBOutletを接続するときは強参照にすることを推奨している。 https://developer.apple.com/videos/play/wwdc2015/407/ (32:30〜あたり)
 In general you should make your outlet strong, especially if you are connecting an outlet to a sub view or to a constraint that&amp;rsquo;s not always going to be retained by the view hierarchy. The only time you really need to make an outlet weak is if you have a custom view that references something back up the view hierarchy and in general that&amp;rsquo;s not recommended.</description>
    </item>
    
    <item>
      <title>【flutter】Rowの中に入れたTextを余っているスペースいっぱいに表示したい</title>
      <link>https://teakun.dev/entry/2022-04-21-flutter-text-in-row-layout/</link>
      <pubDate>Thu, 21 Apr 2022 00:57:28 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2022-04-21-flutter-text-in-row-layout/</guid>
      <description>考えるのは以下のようなケース。
 3つ要素が並んでいて、左右の要素は左右にピッタリ配置 中間の要素はテキストで可変になっていて、スペースが余っている限りいっぱいに表示したい テキストは左寄せで表示   成功   うまく行ったパターン Row( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Container(), // 先頭の要素  Flexible( child: Container( width: double.infinity, padding: const EdgeInsets.only(left: 8), child: Text( &amp;#34;あああああああああああああああああああああああああああああああああ&amp;#34;, overflow: TextOverflow.ellipsis, ), ), ), Container(), // 末尾の要素  ], ), 中間のTextをFlexibleで囲んで、Containerの幅をdouble.infinityにする。 infinityを指定しているからめいっぱいに広がるけど、Flexibleで囲んでいるから要素がoverflowを起こさない。
うまく行かなかったパターン Row( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Container(), // 先頭の要素  Flexible( child: Container( width: double.infinity, padding: const EdgeInsets.only(left: 8), child: Text( &amp;#34;あああああああああああああああああああああああああああああああああ&amp;#34;, overflow: TextOverflow.</description>
    </item>
    
    <item>
      <title>2021</title>
      <link>https://teakun.dev/entry/2021-12-31-2021/</link>
      <pubDate>Fri, 31 Dec 2021 12:50:04 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-12-31-2021/</guid>
      <description>去年もやったので今年も軽くやる。
コロナ かなりコロナが落ち着いて外に出歩く機会が戻ってきた。 今年は2年ぶり地元への帰省もできた。 まだまだ元通りとは行かないけど、このまま収束していってほしい。
仕事 今年は副業にチャレンジした。 水産系のITベンチャーにお世話になって、4月~10月でflutter + railsの開発をした。 新卒4年目になって他の会社がどんな様子が気になっていたこと、flutter・BEの経験を積みたかったことなど、欲しかった経験をまとめて得られてためになった。 flutterもrailsもほぼ未経験の状態から雇ってもらえてありがたかった。今はその会社とはサヨナラしてしまったけどいい経験になった。 来年頭からは別の会社で副業させてもらえる話が進んでいてそちらも楽しみ。
ということで今年は特にflutter, railsを一通り触れるようになったのが成長だった。 両方やりたいと思っていたことだったので良かった一方で、いかにもベンチャーで働きまっせ、みたいな知識ばかり入っているのはちょっと考えどころ。 最終的に自分がそういうところで働きたいのか？というのはよく考えたほうがよさそう。来年は長い目で見て役に立ちそうなことを勉強していきたい。
本業の方はこの1年で自分の仕事はそれほど変わらなかった。もうすぐで5年目になるのでもっと変化をつけていきたい。
生活 変わらず東京に住んでいる。今の住まいはなかなか住心地がよい。どうせリモートワークなのでどこに住んでもよいけど、当面はこのままになりそう。 この1年は家電を買って生活が豊かになるのを感じられたのが良かった。特に洗濯乾燥機は革命だった。ドラムに全部入れるだけでホカホカでパリパリに乾いた服が出てくる。洗剤を自動で投入してくれるのもよいですね。みんな買いましょう。
2022 そろそろ30代も近い。ぼちぼちがんばるぞ。</description>
    </item>
    
    <item>
      <title>GoogleMobileAdsアップデート(7.67.0 -&gt; 8.12.0)</title>
      <link>https://teakun.dev/entry/2021-11-14-googlemobileads-update/</link>
      <pubDate>Sun, 14 Nov 2021 16:29:01 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-11-14-googlemobileads-update/</guid>
      <description>iOSの話。 久しぶりにGoogleMobileAdsSDKのアップデートをしたらIFが変わっていたのでメモ。
interstatial  https://developers.google.com/admob/ios/full-screen-migration?hl=ja  ベータ版のときのドキュメント GADInterstitialAdBetaをGADInterstitialAdに読み替えるとそのまま使える これまではinterstatialが読込中・読み込み完了の状態を持つようになっていたが、広告の読み込みが完了したときだけインスタンスが取得できるようになった    banner  デリゲートメソットのネーミングが刷新  # before func adViewDidReceiveAd(_ bannerView: GADBannerView) {} # after func bannerViewDidReceiveAd(_ bannerView: GADBannerView) {} 手元の環境では大体対応するメソッドがあるので置き換えて完了した。</description>
    </item>
    
    <item>
      <title>【iOS】admobのアダプティブバナーでレイアウトが可変にならなかった問題</title>
      <link>https://teakun.dev/entry/2021-03-08-admob-adaptivebanner-layout/</link>
      <pubDate>Mon, 08 Mar 2021 00:03:52 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-03-08-admob-adaptivebanner-layout/</guid>
      <description>タイトルのまま。 基本的に公式のマニュアルの通りにやれば間違いないがしょうもないハマりどころがあった。
起きた問題  前提: iOS, UIKit,autolayout 以下のようにadSizeを更新してもレイアウトが320*50で固定されてしまう  bannerView.adSize = GADCurrentOrientationAnchoredAdaptiveBannerAdSizeWithWidth(viewWidth) 原因 autolayoutでバナーのviewに対してwidth=320,height=50の制約を貼ってしまっていたため。元々のバナーの320*50の制約が残っていてadSizeを更新してもその制約が優先されるようになっていた。 勝手に更新してくれるのかと思ったけどそんなことはない。
対応 width=320,height=50の制約を剥がす。そのままではviewのレイアウトが定まらずにエラーが出てしまうのでintrinsic sizeのPlaceholderに仮の値を入れておくとよい。 intrinsic sizeについてはこの記事が詳しくて分かりやすい。  ちなみにサンプルコードを実際に開いてみるとintrinsic sizeを入れる方法で実装してあった。</description>
    </item>
    
    <item>
      <title>最近読んだ本とか</title>
      <link>https://teakun.dev/entry/2021-02-06-reading/</link>
      <pubDate>Sat, 06 Feb 2021 23:04:51 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-02-06-reading/</guid>
      <description>最近読んだ本とその感想を書く。今年はたくさん本を読むつもり。
関係ないけどamazonのタイムセールで買ったKindle Oasisがなかなか快適。 軽くて目に優しいので楽だし、何より防水で風呂に持ち込んで本を読めるのが良い。
いつも「時間がない」あなたに 欠乏の行動経済学 人は余裕がないと目の前にしか集中できなくなり、他へ目が回らなくなってさらに余裕がなくなっていく欠乏の悪化を引き起こしてしまう。 というような余裕がない状態について研究した本。余裕がないと直近の心配事を解消するためにリソースが奪われてしまうという話があって心当たりがありすぎる。
ツベルクリンムーチョ (森博嗣) 100編からなるエッセイ集。シリーズ9作目？らしい。 エッセイでは時事的なことはなるべく避けるでおなじみの森博嗣だけど珍しく時事的な話題としてコロナについて触れる内容が多かったのが印象的。もっとも書いてる内容はいつもと同じ…
桜井政博のゲームについて思うこと 2015-2019 スマブラのディレクターの桜井さんがファミ通で連載しているコラムを5年分まとめたもの。 ファミコン時代の苦労話、スマブラの開発の様子、プレイしたゲームの感想などなどいろいろな話が詰まっていて面白かった。連載のまとめなので一回分が見開き2ページになっているのが読みやすくてよい。
自分の中に毒を持て (岡本太郎) タイトルは聞いたことがあったので読んでみた。前半は岡本太郎の人生観が詰まっていて、自分も頑張るぞ！という気持ちになれた。燃える内容で集中して読めたけど、過去に付き合ってきた女の話が途中からひたすら続いていてなんじゃこりゃとなった。それを除けばなかなか面白かったです。</description>
    </item>
    
    <item>
      <title>20210123</title>
      <link>https://teakun.dev/entry/2021-01-23-ghostintheshell/</link>
      <pubDate>Sat, 23 Jan 2021 00:18:34 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-01-23-ghostintheshell/</guid>
      <description>年始ぐらいから攻殻機動隊のSACシリーズをひたすら観ていて、最近やっと見終わった。 攻殻機動隊、名前は知っていたけど何となく観ていなかったアニメ。メカにネットにアクションにと大好きなテーマがてんこ盛りといったところでめちゃくちゃ面白かった。もっと早く観たら良かった。 大きな話の間に単発の話も混ざったりと変化があって、全体を通して飽ることもなかった。 自分は単発の話が好き。 基本的に仕事の昼休憩の時間にみていたけれど、いつの間にか昼休憩にアニメを見る習慣がついた。攻殻機動隊を観終わってからも別のアニメを探しては昼にずっと見ている。なんとなく生活が豊かになったような気がする。
あとから押井守の映画版も観たけど、こっちは話が難しくてついていけないところがあった… また思い出したときに観る。</description>
    </item>
    
    <item>
      <title>Xcode source editor extensionを試した記録</title>
      <link>https://teakun.dev/entry/2021-01-10-try-xcodesourceeditorextension/</link>
      <pubDate>Sun, 10 Jan 2021 22:16:39 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2021-01-10-try-xcodesourceeditorextension/</guid>
      <description>試してみたので過程を残しておく。
エディタ上で選択した範囲からその部分がハイライトされるGitHubのリンクを生成するExtensionを作りたかったが、それはできないということが分かって残念。 環境はBigSur11.1でXCode12.3。
ビルドするまで まずはこのあたりの資料を参考にシンプルなプロジェクトを作ってみる。2017年とちょっと古い資料だけど、基本的な部分は変わっていない。とても参考になった。
 https://speakerdeck.com/takasek/20170916-number-iosdc https://github.com/takasek/XcodeExtensionSample  これを元にシンプルなプロジェクトができたけど、そのままだとXCodeがクラッシュ、コマンドが認識されないなどの問題が起きた。
XCode12以降でビルドできない問題 extensionを作るためにはXCodeKit.frameworkを使う必要があるけれど、XCode12以降ではそれがembedになっている必要がある。
 For compatibility with new security features in macOS 11, Xcode extensions must be built using Xcode 12 and must embed XcodeKit.framework. An Xcode extension rebuilt with these tools remains compatible with older versions of Xcode and macOS.
  https://developer.apple.com/documentation/xcode-release-notes/xcode-12-release-notes  ということで、Embedの設定をEmbed &amp;amp; Signに変えてやるとよい。  一応他にも同じ問題で困っている人がいるようだった。
Extensionの権限がない問題 上の設定の問題が解消してビルドができるようになったが、自分の環境ではまだ新しく作ったコマンドがXCodeで表示されない問題があった。 どうやら作ったExtensionにmacOS自体の機能拡張の権限が渡っていなかったのが原因。  システム環境設定 -&amp;gt; 機能拡張 -&amp;gt; XCode Source Editorから作ったExtensionのチェックを入れ直して解決。</description>
    </item>
    
    <item>
      <title>2020</title>
      <link>https://teakun.dev/entry/2020-12-31-2020/</link>
      <pubDate>Thu, 31 Dec 2020 22:09:42 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2020-12-31-2020/</guid>
      <description>ちょっとだけ振り返る。
コロナ 2020はなんといっても新型コロナウイルスの年だった。 ほとんど会社に行かずとも仕事が完結してしまったこともあり、外出することが激減した。 人と直接話す機会も減って、もちろん外に遊びに行くことも少なくなっている。 この生活がもう1年近く続いているけどまだ慣れきってなくてつらい。 あと1年か2年はこんな生活が続くと見ているけど、そう考えるだけでげんなりしてしまう。
その一方でオンラインで遊ぶ機会が増えた。オンラインボドゲ、オンライン麻雀、switchとか。 zoom飲みも何度かやったけど、画面越しに飲むだけではあんまり盛り上がらなくて微妙。 遊びがセットになっているのがよい。開拓の余地あり。
住まい 新卒で東京に来てからずっと住んでた部屋から2月に引っ越した。1Kでアリだらけの部屋から脱出。 ちょうどコロナ騒ぎが2月くらいから本格的に始まったのでタイミングは完璧だった。 前に住んでいたところは飲食店も少なく静かなファミリー住宅街といった感じで気に入っていたけど、せっかく東京にいるので次の部屋はそれよりも栄えている場所から選んだ。 結果的にはそれが当たりで、ほどよく栄えているほうが生活しやすくて満足。あと、ラーメン屋が多くて最高。
個人開発 9月に2年ぶりくらいに個人アプリをリリースした。途中で飽きてほったらかしにしていたけどやっとこさ完成させた。 開発始めたのが2018年の10月とかなので2年がかり。こまめに作るのが大事。ユーザの数も多いとは言いがたいけど、個人アプリにしては一定の人数に使われていていい感じ。このまま地道に育てていきたい。
ストアのリンク
仕事 基本的にはiOSアプリの開発をやっていて、夏場に4ヶ月くらいバックエンドのチームに移動して仕事した。 これまでiOSアプリの開発の仕事ばかりやっているのが自分の中で不安な部分だったので、まとまった期間でバックエンドの開発を知ることができたのは自分のためになってよかったと思う。 その一方で、戦力になれていたかというと微妙な感じ。 次にバックエンドに行くときはもっと戦力になれるよう働きたい。
あと、自分が長い間デモ作ったり企画を考えていた機能をちゃんと世に出すことができたのがよかった。
2021 2021はブログを書く。まだまだコロナが続きそうだけど、自分で面白いことを見つけて楽しくやっていきたい。</description>
    </item>
    
    <item>
      <title>SwiftのPropertyWrapperを知る</title>
      <link>https://teakun.dev/entry/2020-12-08-swift-propertywrapper/</link>
      <pubDate>Tue, 08 Dec 2020 00:48:36 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2020-12-08-swift-propertywrapper/</guid>
      <description>PropertyWrapperについて1から勉強。
一番シンプルなパターン まずは一番かんたんな例から。始めは色のRGBを表す場合を考えてみる。それぞれの値は0~255で表されていて、それ範囲外の値が来た場合は範囲に収まるようにしたい。ここではRGBを表すためのPropertyWrapperとして、ColorValueを定義する。
@propertyWrapper struct ColorValue { private var value: Int init() { value = 0 } var wrappedValue: Int { get { return value } set { value = min(255, max(0, newValue)) } } } struct Color { @ColorValue var r: Int // @ColorValueのwrappedValueの型と変数の型が一致しないといけない @ColorValue var g: Int @ColorValue var b: Int } var color = Color() color.r = 100 print(color.r) // 100 color.g = 999 print(color.g) // 355 color.</description>
    </item>
    
    <item>
      <title>multipart/form-data入門</title>
      <link>https://teakun.dev/entry/2020-12-02-multipartformdata/</link>
      <pubDate>Wed, 02 Dec 2020 01:43:18 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2020-12-02-multipartformdata/</guid>
      <description>仕事でmultipart/form-dataでファイルアップロードをする実装することになったけど、どういうものか全然わかっていないので調べる。
そもそもなにか HTTPのリクエストで複数のデータをまとめて送るための仕組み。 例えば、プロフィールを登録するような場合に、名前と画像をセットでアップロードするようなときに使う。
header Content-Typeにはこのような指定が入る。
Content-Type: multipart/form-data; boundary=--&amp;lt;バウンダリ文字列&amp;gt;\r\n バウンダリ文字列というのがミソで、これが送信したい複数のデータの区切りになる。 なので、この文字列はデータ中には出てこないような無難な乱数が入るのがよい。
body bodyの例。1つ目にテキスト、2つ目に画像を送るような場合で考える。
--&amp;lt;バウンダリ文字列&amp;gt;\r\n Content-Disposition: form-data; name=&amp;quot;&amp;lt;1つ目の名前&amp;gt;&amp;quot;\r\n \r\n &amp;lt;1つ目のデータ&amp;gt; --&amp;lt;バウンダリ文字列&amp;gt;\r\n Content-Disposition: form-data; name=&amp;quot;&amp;lt;2つ目名前&amp;gt;&amp;quot;; filename=&amp;quot;&amp;lt;ファイル名&amp;gt;&amp;quot;\r\n Content-Type: image/jpeg\r\n \r\n &amp;lt;画像のバイナリ&amp;gt; --&amp;lt;バウンダリ文字列&amp;gt;--\r\n  headerで定義したバウンダリ文字列でデータの区切りを表す。バウンダリ文字列は--から始めないといけない制約がある。 すべての改行は\r\nにする。(この改行の方法をCRLFと呼ぶらしい) 各データの先頭ではContent-Dispositionを指定していて、これがそのデータの情報を表している。あとは必要に応じてContent-Typeなどを指定する。 区切りの最後にもバウンダリ文字列を追加を追加する必要がある。この場合はバウンダリ文字列の最後にも--をつけないといけない。  参考  https://satox.hatenadiary.jp/entry/20110726/1311665904 https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Content-Disposition https://marusunrise2.blogspot.com/2014/06/lfcrcrlf.html  </description>
    </item>
    
    <item>
      <title>ブログ作った</title>
      <link>https://teakun.dev/entry/2020-11-24-start-blog/</link>
      <pubDate>Tue, 24 Nov 2020 23:59:35 +0900</pubDate>
      
      <guid>https://teakun.dev/entry/2020-11-24-start-blog/</guid>
      <description>新しくブログを作った。
一年くらい前まで使っていたはてなブログは今はちょっと勢いがなさそうで、使い続けるのは微妙かな、と思うようになってしまった。 他のブログプラットフォームを調べてみたりもしたけど、今どきはnoteだ！notionだ！とか、新興勢力が出てきて何がなんやらよくわからない。 他のプラットフォームに乗り換えたとしても、また新しい勢力が出てくるのは目に見えている。そんなことを気にしながらブログ書くらいなら、ちょうどweb技術のお勉強にもなりそうだしいっそ自分で作るか〜となった。 で、今回の新ブログにいたる。
新しくブログを作るにあたって、以下のようなことを考えた。
 維持費がかからないか メンテナンスが楽かどうか  wordpressとかはアップデートとかあるよね？重いしめんどくさい   いざとなった脱出しやすいかどうか  独自記法だと他のブログに移行するのが難しい markdownで書きたい    ということで新ブログはとりあえずHugo + Github Pagesで作ってみた。 そのうち独自ドメインとかも取って当ててみたい。
しょうもないけど、Hugoでは記事のパスを自分で決めないといけなくて、ここでちょっと悩んだ。 結果的には $HOME/entry/{記事} にした。 どこに悩むポイントがあるかというと、entry の部分。他の候補としてはposts、articlesあたり。 意外とこれ悩みどころじゃない？ 自分は文字数の少なさと何となくの好みでentryにした。 調べてるとこういう記事もあったりする。 でも結局は好みだし好きなやつにしたらいいよね・・・</description>
    </item>
    
  </channel>
</rss>
